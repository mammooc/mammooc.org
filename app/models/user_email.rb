# frozen_string_literal: true

class UserEmail < ApplicationRecord
  LCHARS    = /\w+\p{L}\p{N}\!\/#\$%&'*+=?^`{|}~}/.freeze
  LOCAL     = /[#{LCHARS.source}]+((\.|\-)[#{LCHARS.source}]+)*/.freeze
  DCHARS    = /A-z\d/.freeze
  SUBDOMAIN = /[#{DCHARS.source}]+(\-+[#{DCHARS.source}]+)*/.freeze
  DOMAIN    = /#{SUBDOMAIN.source}(\.#{SUBDOMAIN.source})*\.[#{DCHARS.source}]{2,}/.freeze
  EMAIL     = /\A#{LOCAL.source}@#{DOMAIN.source}\z/i.freeze

  belongs_to :user
  validate :one_primary_address_per_user
  validates :is_verified, inclusion: {in: [true, false]}
  validates :address,
            presence: true,
            uniqueness: {case_sensitive: false},
            format: {with: EMAIL}

  before_destroy :validate_destroy

  # Please note: If you're deleting one address and change another one in a transaction, you must first destroy and update or create others afterwards!

  def change_to_primary_email
    return if UserEmail.find_by(address: user.primary_email, user: user) == self

    transaction do
      old_primary = UserEmail.find_by(address: user.primary_email, user: user)
      old_primary.is_primary = false
      self.is_primary = true
      old_primary.save! validate: false
      save! validate: false
      one_primary_address_per_user
      raise ActiveRecord::Rollback if errors.present?
    end
  end

  def autogenerated?
    autogenerated = false
    UserIdentity.where(user: user).find_each do |identity|
      autogenerated = true if "autogenerated@#{identity.provider_user_id}-#{identity.omniauth_provider}.com".downcase.match(address.downcase).present?
    end
    autogenerated
  end

  private

  def one_primary_address_per_user
    primary_address = UserEmail.where(user_id: user.id, is_primary: true)
    if is_primary
      if primary_address.size == 1 && primary_address.first.id != id
        # One primary address in DB, adding another one
        errors.add(:is_primary, 'could not be set because another primary address is already stored')
      end
    elsif !is_primary
      if primary_address.empty?
        # No primary address in DB
        errors.add(:is_primary, 'must add this address as primary email')
      elsif primary_address.size == 1 && primary_address.first.id == id
        # Update last existing primary address
        errors.add(:is_primary, 'could not be changed because there is no other primary address')
      end
    end
  end

  def validate_destroy
    # Only allow deletion of non-primary addresses
    return unless is_primary

    throw :abort
  end
end
